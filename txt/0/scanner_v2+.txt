import telebot
import multiprocessing
import asyncio
import logging
import time
import json
from scraper import spider
from sql import analyze_vulnerabilities as analyze_sql_vulnerabilities, load_scraped_data
from xss import analyze_xss
from csrf import analyze_csrf
from lfi import analyze_lfi
from rfi import analyze_rfi
from idor import analyze_idor
from recommendations import generate_recommendation
from requests.exceptions import ConnectionError, ReadTimeout
from tenacity import retry, stop_after_attempt, wait_fixed
from aiohttp import ClientSession, FormData
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton

# Укажите токен вашего бота
TOKEN = '6979756435:AAG1dpmdnqwkBs6yXb1DJ9jpWhsCc8a16t0'
bot = telebot.TeleBot(TOKEN)

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Главное меню
main_menu_markup = telebot.types.ReplyKeyboardMarkup(resize_keyboard=True)
main_menu_markup.add('Начать сканирование', 'Помощь', 'О боте')

# Меню для выбора типа уязвимостей
scan_menu_markup = telebot.types.ReplyKeyboardMarkup(resize_keyboard=True)
scan_menu_markup.add('SQL Injection', 'XSS', 'CSRF', 'LFI', 'RFI', 'IDOR')
scan_menu_markup.add('Назад')


@retry(stop=stop_after_attempt(3), wait=wait_fixed(5))
async def send_message_with_retry(chat_id, message, timeout=60):
    try:
        async with ClientSession() as session:
            url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
            payload = {
                'chat_id': str(chat_id),
                'text': message,
                'parse_mode': 'HTML'
            }
            async with session.post(url, data=payload, timeout=timeout) as response:
                if response.status != 200:
                    logger.error(f"Failed to send message: {await response.text()}")
                else:
                    logger.info(f"Message sent successfully: {message}")
    except (ConnectionError, ReadTimeout) as e:
        logger.error(f"Error sending message: {e}")
        raise


async def send_document_with_retry(chat_id, document_path, timeout=60):
    try:
        async with ClientSession() as session:
            url = f"https://api.telegram.org/bot{TOKEN}/sendDocument"
            form = FormData()
            form.add_field('chat_id', str(chat_id))
            form.add_field('document', open(document_path, 'rb'))
            async with session.post(url, data=form, timeout=timeout) as response:
                if response.status != 200:
                    logger.error(f"Failed to send document: {await response.text()}")
                else:
                    logger.info(f"Document sent successfully: {document_path}")
    except (ConnectionError, ReadTimeout) as e:
        logger.error(f"Error sending document: {e}")
        raise


async def spider_and_analyze(url, chat_id, analyze_func):
    try:
        await send_message_with_retry(chat_id, "Сканирование началось, пожалуйста, подождите...")

        logger.info(f"Starting spider for URL: {url}")
        await spider(url)  # Запуск скрапера
        logger.info(f"Spider finished for URL: {url}")

        await send_message_with_retry(chat_id, "Сканирование завершено, анализ данных...")

        scraped_data = load_scraped_data('scraped_data.json')  # Загрузка данных скрапера
        logger.info(f"Scraped data loaded: {scraped_data}")

        vulnerabilities = await analyze_func(scraped_data)  # Анализ уязвимостей
        logger.info(f"Vulnerabilities found: {vulnerabilities}")

        # Формирование сообщения и файла с результатами
        results_message = format_results(vulnerabilities)
        detailed_report_path = generate_detailed_report(scraped_data, vulnerabilities)

        # Отправка сообщения с результатами
        if results_message:
            await send_long_message(chat_id, results_message)

        # Отправка файла с подробными данными
        await send_document_with_retry(chat_id, detailed_report_path)

        return vulnerabilities
    except Exception as e:
        logger.error(f"Error in spider_and_analyze: {e}")
        await send_message_with_retry(chat_id, f"Произошла ошибка при анализе: {e}")
        return {'error': str(e)}


def run_async_in_process(queue, url, chat_id, analyze_func):
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        results = loop.run_until_complete(spider_and_analyze(url, chat_id, analyze_func))
        queue.put(results)
    except Exception as e:
        logger.error(f"Error in run_async_in_process: {e}")
        queue.put({'error': str(e)})
    finally:
        loop.close()


@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    bot.reply_to(message, """
    Привет! Я бот для сканирования уязвимостей на веб-страницах.

    Вот список доступных команд:

    /start - начать работу с ботом
    /help - отобразить это сообщение

    /scan_sql <URL> - сканировать указанную страницу на наличие SQL-инъекций
    /scan_xss <URL> - сканировать указанную страницу на наличие Межсайтового скриптинга (XSS)
    /scan_csrf <URL> - сканировать указанную страницу на наличие Межсайтовой подделки запроса (CSRF)
    /scan_lfi <URL> - сканировать указанную страницу на наличие Локального включения файлов (LFI)
    /scan_rfi <URL> - сканировать указанную страницу на наличие Удаленного включения файлов (RFI)
    /scan_idor <URL> - сканировать указанную страницу на наличие Небезопасных прямых ссылок на объекты (IDOR)

    Пример использования:
    /scan_sql https://example.com/page

    Либо воспользуйтесь кнопочным меню Бота!
    """, reply_markup=main_menu_markup)


@bot.message_handler(func=lambda message: message.text == 'Начать сканирование')
def start_scan(message):
    bot.reply_to(message, "Выберите тип уязвимости для сканирования:", reply_markup=scan_menu_markup)


@bot.message_handler(func=lambda message: message.text == 'Помощь')
def help(message):
    bot.reply_to(message, """
    Вот список доступных команд:

    /start - начать работу с ботом
    /help - отобразить это сообщение

    /scan_sql <URL> - сканировать указанную страницу на наличие SQL-инъекций
    /scan_xss <URL> - сканировать указанную страницу на наличие Межсайтового скриптинга (XSS)
    /scan_csrf <URL> - сканировать указанную страницу на наличие Межсайтовой подделки запроса (CSRF)
    /scan_lfi <URL> - сканировать указанную страницу на наличие Локального включения файлов (LFI)
    /scan_rfi <URL> - сканировать указанную страницу на наличие Удаленного включения файлов (RFI)
    /scan_idor <URL> - сканировать указанную страницу на наличие Небезопасных прямых ссылок на объекты (IDOR)

    Пример использования:
    /scan_sql https://example.com/page

    Либо воспользуйтесь кнопочным меню Бота!
    """, reply_markup=main_menu_markup)


@bot.message_handler(func=lambda message: message.text == 'О боте')
def about(message):
    about_text = (
        "Этот бот позволяет сканировать веб-приложения на наличие различных уязвимостей:\n"
        "- SQL Injection\n"
        "- XSS (Cross-Site Scripting)\n"
        "- CSRF (Cross-Site Request Forgery)\n"
        "- LFI (Local File Inclusion)\n"
        "- RFI (Remote File Inclusion)\n"
        "- IDOR (Insecure Direct Object Reference)\n\n"
        "Используемые технологии:\n"
        "- Python\n"
        "- Библиотеки: requests, aiohttp, telebot\n"
        "- Инструменты для анализа уязвимостей\n\n"
        "Важно: этот бот может выдавать ложные срабатывания и не является абсолютно достоверным инструментом по поиску и устранению уязвимостей веб-приложений."
    )
    bot.reply_to(message, about_text, reply_markup=main_menu_markup)


@bot.message_handler(func=lambda message: message.text == 'Назад')
def go_back(message):
    bot.reply_to(message, "Вы вернулись в главное меню. Выберите действие:", reply_markup=main_menu_markup)


@bot.message_handler(func=lambda message: message.text in ['SQL Injection', 'XSS', 'CSRF', 'LFI', 'RFI', 'IDOR'])
def handle_scan_type(message):
    scan_type_to_function = {
        'SQL Injection': analyze_sql_vulnerabilities,
        'XSS': analyze_xss,
        'CSRF': analyze_csrf,
        'LFI': analyze_lfi,
        'RFI': analyze_rfi,
        'IDOR': analyze_idor
    }
    scan_type = message.text
    bot.reply_to(message, f"Введите URL для сканирования на наличие {scan_type}. Например: http://example.com",
                 reply_markup=telebot.types.ReplyKeyboardMarkup(resize_keyboard=True).add('Назад'))
    bot.register_next_step_handler(message, lambda m: handle_scan(m, scan_type_to_function[scan_type], scan_type))


def handle_scan(message, analyze_func, scan_type):
    try:
        url = message.text.strip()
        if url.startswith("http"):
            bot.reply_to(message, f"Начинаем сканирование сайта на наличие {scan_type}: {url}")
            queue = multiprocessing.Queue()
            process = multiprocessing.Process(target=run_async_in_process,
                                              args=(queue, url, message.chat.id, analyze_func))
            process.start()

            # Проверка состояния процесса и обновление пользователя
            while process.is_alive():
                bot.send_chat_action(message.chat.id, 'typing')
                time.sleep(5)  # Обновление каждые 5 секунд

            process.join()  # Ожидание завершения процесса
            results = queue.get()  # Получение результатов из процесса

            logger.info(f"Results received: {results}")

            if 'error' in results:
                bot.reply_to(message, f"Произошла ошибка: {results['error']}")
            else:
                results_message = format_results(results)
                logger.info(f"Results message to send: {results_message}")
                asyncio.run(send_long_message(message.chat.id, results_message))
        else:
            bot.reply_to(message, "Пожалуйста, введите валидный URL, начиная с http:// или https://")
    except Exception as e:
        logger.error(f"Error in handle_scan: {e}")
        bot.reply_to(message, f"Произошла ошибка: {e}")


def format_results(vulnerabilities):
    results_message = "Результаты сканирования:\n\n"
    for result in vulnerabilities:
        if result.get('is_vulnerable'):
            recommendation = generate_recommendation(result['type'])
            scan_data = (
                f"Мы внедрили полезные нагрузки {result['type']} в параметр {result['parameter']} и проверили наличие сообщений об ошибках в ответе."
                if result['type'] == 'Error-based' else
                f"Мы внедрили полезные нагрузки {result['type']} в параметр {result['parameter']} и проверили задержку во времени ответа."
                if result['type'] == 'Time-based' else
                f"Мы внедрили полезные нагрузки {result['type']} в параметр {result['parameter']} и проверили ответ системы.")

            results_message += (f"URL: {result['url']}\n"
                                f"Параметр: {result['parameter']}\n"
                                f"Уязвимость: {'Да' if result['is_vulnerable'] else 'Нет'}\n"
                                f"Тип уязвимости: {result['type']}\n"
                                f"Payload: {result.get('payload', 'N/A')}\n"
                                f"Время отклика: {result.get('response_time', 'N/A')}\n"
                                f"Данные сканирования: {scan_data}\n"
                                f"Рекомендация: {recommendation}\n"
                                "-----------------------------------\n")

    if results_message == "Результаты сканирования:\n\n":
        results_message = "Результаты сканирования:\nУязвимостей не найдено."

    logger.info(f"Formatted results message: {results_message}")
    return results_message


def generate_detailed_report(scraped_data, vulnerabilities):
    report = "Детальный отчет сканирования:\n\n"
    report += "=== Данные скрапера ===\n"
    for page in scraped_data:
        report += f"URL: {page['URL']}\n"
        report += f"Метод: {page['Method']}\n"
        report += f"Параметры: {json.dumps(page['Parameters'], indent=4)}\n"
        report += f"Заголовок страницы: {page['Page Title']}\n"
        report += f"Размер страницы: {page['Page Size']}\n"
        report += f"Код состояния: {page['Status Code']}\n"
        report += "Формы:\n"
        for form in page.get('Forms', []):
            report += f"  Action: {form['action']}\n"
            report += f"  Method: {form['method']}\n"
            report += "  Inputs:\n"
            for input_tag in form['inputs']:
                report += f"    - {input_tag}\n"
        report += "-----------------------------------\n"

    report += "\n=== Найденные уязвимости ===\n"
    for result in vulnerabilities:
        report += f"URL: {result['url']}\n"
        report += f"Параметр: {result['parameter']}\n"
        report += f"Уязвимость: {'Да' if result['is_vulnerable'] else 'Нет'}\n"
        report += f"Тип уязвимости: {result['type']}\n"
        if 'payload' in result:
            report += f"Payload: {result['payload']}\n"
        if 'response_time' in result:
            report += f"Время отклика: {result['response_time']}\n"
        report += f"Рекомендация: {generate_recommendation(result['type'])}\n"
        report += "-----------------------------------\n"

    report_path = "report.txt"
    with open(report_path, 'w', encoding='utf-8') as file:
        file.write(report)
    logger.info(f"Detailed report generated at {report_path}")
    return report_path


async def send_long_message(chat_id, message):
    max_message_length = 4096
    for i in range(0, len(message), max_message_length):
        part = message[i:i + max_message_length]
        await send_message_with_retry(chat_id, part)
        logger.info(f"Sent message part: {part}")


if __name__ == "__main__":
    try:
        bot.polling(none_stop=True, interval=1, timeout=60)
    except Exception as e:
        logger.error(f"Error during polling: {e}")